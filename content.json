{"meta":{"title":"Topredator","subtitle":"人生若只如初见","description":"Topredator的个人博客","author":"Topredator","url":"https://topredator.github.io","root":"/"},"pages":[{"title":"about","date":"2019-03-16T07:32:26.000Z","updated":"2019-03-16T07:32:26.689Z","comments":true,"path":"about/index.html","permalink":"https://topredator.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-03-16T07:44:51.000Z","updated":"2019-03-16T07:45:28.557Z","comments":true,"path":"categories/index.html","permalink":"https://topredator.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"iOS推送TPPush库的使用","slug":"iOS推送TPPush库的使用","date":"2019-03-17T09:19:32.000Z","updated":"2019-03-17T09:21:38.559Z","comments":true,"path":"2019/03/17/iOS推送TPPush库的使用/","link":"","permalink":"https://topredator.github.io/2019/03/17/iOS推送TPPush库的使用/","excerpt":"前言随着互联网日新月异的蓬勃发展，我们的生活已经进入信息时代，而移动设备的普及，让人们的生活得到很大的改善。每天我们都会接到海量的消息，让我们足不出户的就能了解到世界各地的新闻。作为一个移动领域的开发者，了解移动应用接收到各个平台的推送信息的原理是必不可少的。由于程序猿本猿是一名iOS开发攻城狮，本文只对iOS系统的远程推送服务进行分析~~","text":"前言随着互联网日新月异的蓬勃发展，我们的生活已经进入信息时代，而移动设备的普及，让人们的生活得到很大的改善。每天我们都会接到海量的消息，让我们足不出户的就能了解到世界各地的新闻。作为一个移动领域的开发者，了解移动应用接收到各个平台的推送信息的原理是必不可少的。由于程序猿本猿是一名iOS开发攻城狮，本文只对iOS系统的远程推送服务进行分析~~ 原理 整个推送过程分为两部分：服务注册 和 内容推送流程 推送服务的注册如图所示： 首先，在本地app打开的同时，客户端会向苹果的推送服务器APNs请求注册推送服务，然后APNs会返回一个 device token(唯一令牌) ，此时 Client与APNs就建立起了连接，然后客户端会把这个token发送给自己的服务器”备案”。也就是让服务器记住此设备。此时，前期的准备工作就已经完善。 内容推送流程如图所示 ： 注册完成后，如果服务器需要给处于 Terminate状态 的客户端发送消息，需要把消息带着设备token发送给APNs，APNs会通过长连接把消息推送个设备 整个过程需要处理的API： 1234567- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; ///① 进行注册、注册代码省略&#125;///② 处理APNs返回的token, 需要将NSData类型转为字符串类型- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken;///③ 推送的监听处理, 需要对推送过来的通知进行处理- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo； 自定义通知处理库 –TPPush由于通知处理已经比较成熟，涌现了好多优秀的开源第三方库，如：个推、极光、友盟等，TPPush库是建立在个推的基础上进行的二次封装。做到了无感知的进行token处理、推送监听处理，只需要调用API注册以及对消息体的接收处理 TPPush内部原理：Method-swizzling + runtime检测在 Appdelegate 中是否实现了 编号②③的方法，如果已经实现，就是用 Method-swizzling 进行 hook，否则，动态添加 1234567891011121314151617181920212223242526@implementation TPPushManager// 注入设备Token- (void)injectionDeviceToken &#123; Class class = kApplicationDelegate.class; SEL localSEL = @selector(application:didRegisterForRemoteNotificationsWithDeviceToken:); SEL tpSEL = @selector(tpApplication:didRegisterForRemoteNotificationsWithDeviceToken:); Method localMethod = class_getInstanceMethod([self class], localSEL); // 如果appdelegate 实现了 if ([kApplicationDelegate respondsToSelector:localSEL]) &#123; TPSwizzlingClassAndInstanceMethod(class, self.class, localSEL, tpSEL); &#125; else &#123; // appdelegate 没有实现 class_addMethod(class, localSEL, method_getImplementation(localMethod), method_getTypeEncoding(localMethod)); &#125;&#125;// 注入远程通知方法- (void)injectionRemoteNotificationMethod &#123; Class class = kApplicationDelegate.class; SEL remoteSEL = @selector(application:didReceiveRemoteNotification:); SEL tpSEL = @selector(tpApplication:didReceiveRemoteNotification:); Method remoteMethod = class_getInstanceMethod([self class], remoteSEL); if ([kApplicationDelegate respondsToSelector:remoteSEL]) &#123; TPSwizzlingClassAndInstanceMethod(class, self.class, remoteSEL, tpSEL); &#125; else &#123; class_addMethod(class, remoteSEL, method_getImplementation(remoteMethod), method_getTypeEncoding(remoteMethod)); &#125;&#125; 注释：交换方法是交换TPPushManage类与Appdelegate类的方法 TPPush的使用12pod库引入：pod &apos;TPPush&apos;添加头文件: #import &lt;TPPush/TPPush.h&gt; 首先注册 123456- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; // 个推平台注册app后，会得到三个参数id/key/secret 通过这三个参数生成TPPushGTModel [TPPushInterface registerNotificationWithModel:TPGTPushModel(@&quot;xxxx&quot;, @&quot;xxxxxxx&quot;, @&quot;xxxxxxxxxx&quot;)]; return YES;&#125; 接收消息的处理 12345678910111213/** TPPush不仅会对远程推送进行接受处理，而且包含本地通知处理，原理同上* 接收消息分两种方式：通知、代理*/// 下面是通知的方式，TPPushReceiveRemoteNotification、TPPushReceiveLocalNotification是内部自定义的通知key，只要监听就能处理 [NSNotificationCenter.defaultCenter addObserver:self selector:@selector(testLocalNotification:) name:TPPushReceiveLocalNotification object:nil]; [NSNotificationCenter.defaultCenter addObserver:self selector:@selector(testLocalNotification:) name:TPPushReceiveRemoteNotification object:nil];// 代理的方式: 首先要遵循自定义协议&lt;TPPushDataSource&gt;// 处理远程推送通知- (void)handleRemoteNotification:(NSDictionary *)notification;// 处理本地通知- (void)handleLocalNotification:(NSDictionary *)notification; 结语​ 以上为推送的大致原理及TPPush库的简单介绍及使用。感兴趣的同学可以去我的Github查看源码。另附上 Demo地址","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://topredator.github.io/tags/iOS/"}]},{"title":"iOS客户端启动原理","slug":"iOS客户端启动原理","date":"2019-03-16T11:06:46.000Z","updated":"2019-03-16T11:22:56.750Z","comments":true,"path":"2019/03/16/iOS客户端启动原理/","link":"","permalink":"https://topredator.github.io/2019/03/16/iOS客户端启动原理/","excerpt":"摘要 T(APP总启动时间) = T1(main()之前的加载时间)+T2(main()之后的加载时间)T1 = 系统dylib(动态链接库) 和 自身APP可执行文件加载T2 = 构建第一个界面并完成渲染展示","text":"摘要 T(APP总启动时间) = T1(main()之前的加载时间)+T2(main()之后的加载时间)T1 = 系统dylib(动态链接库) 和 自身APP可执行文件加载T2 = 构建第一个界面并完成渲染展示 一、main()之前的加载过程系统首先加载可执行文件，然后加载动态链接库dyld。（镜像） dyld包括：framework，runtime方法的libobjc， 系统级别的libSystem(如:GCD,Block) dyld优点：代码共用、易于维护、减少可执行文件体积 所有动态链接库和静态库.a及所有的类文件编译后的.o文件最终都由dyld加载到内存中，每个镜像都由一个imageLoader类负责加载 加载步骤 load dylibs image 读取镜像文件 Rebase image Bind image Objc setup initializers load dylibs image 分析依赖的动态库、找到动态库的mach-o文件、打开文件、验证文件、签名、调用mmap() 优化：减少非系统库的依赖、合并非系统库、使用静态资源(代码写入主程序) Rebase/Bind 可执行文件和动态链接库虚拟内存中加载地址每次启动不固定，所以需要2步修复镜像中的资源指针，指向正确的地址 Rebase：修复当前镜像内部的资源指针；读入内存、加密验证；IO是瓶颈 Bind：查询符号表来指向跨境像资源，CPU是瓶颈。 优化：减少Objc类数量、减少selector数量、减少C++虚函数数量 Objc setup 主要作用 ：注册Objc类、把category定义插入列表、保证每个selector唯一 initializers 属于动态调整，开始在堆栈中写入内容；作用：+load()函数、C++的构造函数属性函数、静态全局变量的创建。Objc的+load()及C++静态构造函数，保证每个执行的方法都可以找到所依赖的动态库 main()之前耗时优化点 减少不必要的framework，因为动态链接比较耗时 合并或者删减一些OC类，清理项目中没用到的类 减少一些无用的静态变量 删减没用到或者已经废弃的方法 将不必须在+load()方法中的操作延迟到+initialize中 二、main()之后的加载主要是试图渲染 准备阶段 图片的解码 布局 首页UIView 的 layoutSubviews运行 绘制 首页UIView 的 drawRect运行 各种服务启动、必要的数据创建与读取 优化：不使用xib或者storeboard，直接代码加载首试图、NSLog打印会隐式的创建Calendar，减少启动时各种业务的log、启动时的网络请求，统一异步线程中执行","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://topredator.github.io/tags/iOS/"}]},{"title":"UML图关系","slug":"UML图关系","date":"2019-03-16T10:58:34.000Z","updated":"2019-03-16T11:03:47.333Z","comments":true,"path":"2019/03/16/UML图关系/","link":"","permalink":"https://topredator.github.io/2019/03/16/UML图关系/","excerpt":"UML类图的六大关系分析","text":"UML类图的六大关系分析 泛化（generalization） 是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。 继承关系（老虎 －▷动物）:带三角箭头的实线，箭头指向父类 实现（Realization） 是一种类与接口的关系，表示类是接口所有特征和行为的实现. 类与接口关系（······▷）：带三角箭头的虚线，箭头指向接口 关联（Association） 是一种拥有的关系，它使一个类知道另一个类的属性和方法（单双向）； 拥有关系（老师－学生→课程）：带普通箭头的实心线，指向被拥有者（单项有箭头） 聚合（Aggregation） 整体与部分关系(部分离开整体可以单独存在) （汽车♢→轮胎）: 带空心菱形的实心线，菱形指向整体 组合（Composition） 整体与部分(部分不能离开整体单独存在) （公司♦→部门）:带实心菱形的实线，菱形指向整体 依赖（Dependence） 是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖. 使用关系(方法参数/对静态方法调用)（····＞）：带箭头的虚线，指向被使用者 各种关系的强弱顺序：泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖","categories":[],"tags":[{"name":"UML","slug":"UML","permalink":"https://topredator.github.io/tags/UML/"}]},{"title":"Git的命令使用","slug":"Git的命令使用","date":"2019-03-15T07:02:36.604Z","updated":"2019-03-16T08:37:24.604Z","comments":false,"path":"2019/03/15/Git的命令使用/","link":"","permalink":"https://topredator.github.io/2019/03/15/Git的命令使用/","excerpt":"常用的命令使用","text":"常用的命令使用 配置git config [--local / --gloab / --system] user.name &#39;XXXXX&#39;git config [--local / --gloab / --system] user.email &#39;XXXX&#39;注释：local 区域为本仓库 / global 当前用户的所有仓库 / system 本系统的所有用户 loggit log --all 查看所有分支的历史 git log --all --graph 查看图形化的 log 地址 git log --oneline 查看单行的简洁历史 git log --oneline -n4 查看最近的四条简洁历史 git log --oneline --all -n4 --graph 查看所有分支最近 4 条单行的图形化历史 git help --web log 跳转到git log 的帮助文档网页 git mv readme readme.md 直接用git更改文件名 git cat-file -p &#39;commitId&#39; 查看commit对象 比较两次commit差异 git diff &#39;commitId1&#39; &#39;commitId2&#39; 或者 git diff HEAD [HEAD^/HEAD~1] 暂存区与HEAD的比较 git diff --cached ####更改之前的commit提交的信息 git rebase -i [super commitId] pick 改为 reword/r 合并多个commitgit rebase -i [super commitId] 保留一个pick，将需要融合的commit方到pick的下面，前面的pick改为 squash/s 取消合并git rebase --abort 分支创建： git branch &lt;branchName&gt; 查看： git branch(本地) git branch -a(远端) 切换： git checkout &lt;branchName&gt; 创建+切换： git checkout -b &lt;branchName&gt; 删除： git branch -d &lt;branchName&gt; git branch -D &lt;branchName&gt;(强行删除) git push &lt;origin&gt; --delete &lt;branchName&gt;(删除远端分支) 合并： git merge &lt;branchName&gt; git rebase &lt;branchName&gt; merge 快速合并，看不到曾经合并；merge –no-ff 普通合并，可看历史合并； 查看分支合并图： git log --graph 拉取远端分支（本地无此分支）： git checkout -b &lt;branchName&gt; &lt;origin&gt;/&lt;branchName&gt; 若失败，先fetch，再执行 标签创建： git tag &lt;tagName&gt; git tag &lt;tagName&gt; &lt;commit id&gt; 查看： git tag git show &lt;tagName&gt; 给已提交的内容打tag： git tag &lt;tagName&gt; &lt;commit id&gt; 指定标签信息： git tag -a &lt;tagName&gt; -m &quot;xxx&quot; 删除： git tag -d &lt;tagName&gt; git push &lt;origin&gt; :ref/tags/&lt;tagName&gt;(删除远端，先删除本地) 推送： git push &lt;origin&gt; &lt;tagName&gt; git push &lt;origin&gt; --tags 关联git remote add &lt;origin&gt; &lt;url&gt; 推送： git push -u origin master(第一次推送) git push &lt;origin&gt; master 克隆： git clong &lt;url&gt; 本地分支与远端分支建立连接： git branch --set-upstream-to &lt;localBranchName&gt; &lt;origin&gt;/&lt;remoteBranchName&gt; 储藏储藏： git stash 查看储藏现场： git stash list 恢复现场： git stash apply(不删除现场) git stash pop(删除现场) 撤销没有add，没有commit： git checkout --file &lt;file&gt; add后，没有commit： git reset HEAD &lt;file&gt; git reset HEAD add且commit： git reset --hard &lt;HEAD^&gt; git reset --hard &lt;commit id&gt;","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://topredator.github.io/tags/Git/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-03-15T05:37:18.779Z","updated":"2019-03-15T05:37:18.779Z","comments":true,"path":"2019/03/15/hello-world/","link":"","permalink":"https://topredator.github.io/2019/03/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}